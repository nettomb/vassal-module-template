package my_custom_component;

import VASSAL.build.Buildable;
import VASSAL.build.GameModule;
import VASSAL.build.module.GlobalOptions;
import VASSAL.build.module.Map;
import VASSAL.build.module.ModuleExtension;
import VASSAL.build.module.documentation.HelpFile;
import VASSAL.command.Command;
import VASSAL.command.CommandEncoder;
import VASSAL.command.RemovePiece;
import VASSAL.configure.BooleanConfigurer;
import VASSAL.configure.IntConfigurer;
import VASSAL.counters.BasicPiece;
import VASSAL.tools.DataArchive;

import javax.imageio.ImageIO;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.*;
import java.net.URL;
import java.util.*;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;


public final class AnimatedDice extends ModuleExtension implements CommandEncoder, Buildable{
    private GameModule gameModule;
    private DataArchive dataArchive;
    private String ICONS_IMAGES_PATH = "Cursor/";
    private String RED_DIE_FOLDER_PATH = "DiceImages/RED DIE/";
    private String HESITANT_RED_DIE_FOLDER_PATH = "DiceImages/HRED DIE/";
    private String WHITE_DIE_FOLDER_PATH = "DiceImages/WHITE DIE/";
    private String HESITANT_WHITE_DIE_FOLDER_PATH = "DiceImages/HWHITE DIE/";
    private String RED_HESITANT_DIE_INDEXES = "DiceImages/Hesitant Red Die Indexes.txt";
    private String WHITE_HESITANT_DIE_INDEXES = "DiceImages/Hesitant White Die Indexes.txt";
    private final String ANIMATED_DICE_PREFERENCES = "Animated 3D Dice";
    private final String FRAME_RATE_SETTINGS = "frameRateSettings";
    private final String DICE_POSITION_SETTINGS = "dicePositionSettings";
    private final String ONE_DIE_BUTTON_SETTINGS = "oneDieButtonSettings";
    private final String TWO_DICE_BUTTON_SETTINGS = "twoDiceButtonSettings";
    private final String BUTTONS_INDEX_SETTINGS = "buttonsIndexSettings";
    private final String DICE_ON_SCREEN_DURATION_SETTINGS = "diceOnScreenDurationSettings";
    private final String SHUFFLE_SOUND_SETTINGS = "shuggleSoundSettings";
    private final String DICE_SOUND_SETTINGS = "diceSoundSettings";
    private int dicePositionSettings;
    private int MAX_HORIZONTAL_OFFSET = 0;
    private int IMAGE_SIZE = 250;
    private boolean isImageVisible; // establish if last dice frame is still visible in the screen so that the button is in Hide mode.
    private boolean isAnimationInProgress = false; // prevents mousePress action before animation finishes.
    private JButton oneDieButton;
    private boolean oneDieButtonVisible;
    private JButton twoDiceButton;
    private boolean twoDiceButtonVisible;
    private int diceToolbarIndex;
    private int[] mouseBiasFactor; // Set of ints generated by mouse movement which will influence dice results
    private final int NUMBER_OF_DICE = 2; // number of dices rolled
    private int NUMBER_OF_SIDES = 6; // number of sides of a die
    private long imageDelay; // The number of MILLISECONDS between the display actions.
    private int currentFrame;
    private int frameRate;
    private boolean isShuffleSoundOn;
    private boolean isDiceSoundOn;
    private final int MAX_FRAME_RATE = 60;
    private final int MIN_FRAME_RATE = 35;
    private int onScreenDuration;
    private final int MAX_ON_SCREEN_DURATION = 1000;
    private final int MIN_ON_SCREEN_DURATION = 0;
    private ScheduledExecutorService scheduler; // Controls the frame rate of the displayed images
    //private List<Image> images; // to be fed with the dice images that will be drawn on the pieces
    private HashMap<String, HashMap<Integer, ArrayList<Image>>> imagesCache1; // set of preloaded images for each die and each result on the form: "Red": 6: List of images
    private HashMap<String, HashMap<Integer, ArrayList<Image>>> imagesCache2;
    private boolean isFeedingCache1;
    private boolean isFeedingCache2;
    private boolean oddRound = true;
    private int[] lastDiceImageFolderIndexes = new int[]{0,0}; // Keeps the last two dice image folders indexes stored to prevent immediate repetition of same animation
    private int lastNumberOfDiceRolled = 1;
    private HashMap<Integer, HashMap<Integer, ArrayList<Integer>>> redHesitantDieFolderBuilder; //Keep data taken from a txt file to reproduce the folder names for hesitant dice. Key: Animation number / Key: die result / value: rejected die value (middle number in folder name)
    private HashMap<Integer, HashMap<Integer, ArrayList<Integer>>> whiteHesitantDieFolderBuilder;
    private HashMap<String, Object[]> lastAnimationUsed; // Keeps track of the last animation used to prevent immediate repetition and to control hesitant dice probabilities. Must have the form ["Red", [4, true]] where true is for hesitant die
    private double hesitantDieProbability;
    private final int NUMBER_OF_DIE_ANIMATIONS = 27; // ALTER THAT IF MORE ANIMATIONS ARE ADEED
    private final int NUMBER_OF_HESITANT_DIE_ANIMATIONS = 5;
    //private boolean feedingImages; // Checks if the thread for loading images is still running
    private Object soundObject = new Object();
    private final Object feedingImagesLock = new Object(); // Lock to be used by threads to synchronize the feeding images process
    private byte[] dieAudioData;
    private byte[] diceAudioData;
    private byte[] shakingDiceAudioData;
    private CountDownLatch latch = new CountDownLatch(1);
    private Cursor dieCursor;
    private boolean actionInProgress = false;
    private HashMap<String, BasicPiece[]> pieces; // pieces are added to this array to be displayed in order
    private final Map currentMap;

    // TEST CODE START
    private boolean testRunning = false;
    private int playSoundsThreadCounter = 0;
    private int animationRunTaskCounter = 0;
    private int buttonTimerCounter = 0;
    private int buttonResetThreadCouter = 0;
    private int drawDiceFoderThreadCounter = 0;
    private HashMap<String, HashMap< String, HashMap<Integer, ArrayList<Image>>>> cachesRegistry = new HashMap<>();
    // TEST CODE END

    public AnimatedDice(){
        super(GameModule.getGameModule().getDataArchive());
        isImageVisible = false;
        gameModule = GameModule.getGameModule();
        dataArchive = gameModule.getDataArchive();
        currentMap = GameModule.getGameModule().getComponentsOf(Map.class).get(0);
        dicePositionSettings = 0;
        frameRate = 45;
        onScreenDuration = 5;
        oneDieButtonVisible = true;
        twoDiceButtonVisible = true;
        isShuffleSoundOn = true;
        isDiceSoundOn = true;
        currentFrame = 0;
        hesitantDieProbability = 0.3; // must be multiplied by animations Ratio to ge the actual probability
        lastAnimationUsed = new HashMap<String, Object[]>(){{
            put("white", new Object[]{0, false});
            put("red", new Object[]{0, false});
        }};
        // INITIALIZES THE PRELOADED IMAGES HASHMAP
        imagesCache1 = new HashMap<>();
        imagesCache2 = new HashMap<>();
        imagesCache1.put("white", new HashMap<>());
        imagesCache1.put("red", new HashMap<>());
        imagesCache2.put("white", new HashMap<>());
        imagesCache2.put("red", new HashMap<>());
        for (int i = 1; i <= NUMBER_OF_SIDES; i++){
            imagesCache1.get("white").put(i, new ArrayList<>());
            imagesCache1.get("red").put(i, new ArrayList<>());
            imagesCache2.get("white").put(i, new ArrayList<>());
            imagesCache2.get("red").put(i, new ArrayList<>());
        }

        // CREATE THE ARRAY INDICATING WHAT FOLDERS BRING HESITANT DIE ANIMATIONS
        redHesitantDieFolderBuilder = CreateHesitantDieFolderBuilder(RED_HESITANT_DIE_INDEXES);
        whiteHesitantDieFolderBuilder = CreateHesitantDieFolderBuilder(WHITE_HESITANT_DIE_INDEXES);

        // GET RESOURCES
        loadSounds(); // Preloads sounds for dices

        // set icon for shuffling
        /*URL iconURL = null;
        try {
            iconURL = dataArchive.getURL("Cursor/DieCursor.png");
            //System.out.println("icon URL: " + iconURL);
            BufferedImage dieCursorImage = ImageIO.read(iconURL);
            dieCursor = Toolkit.getDefaultToolkit().createCustomCursor(dieCursorImage, new Point(0,0), "Custom Die Cursor");
            ImageIcon icon = new ImageIcon(iconURL);
        } catch (IOException e) {
            System.out.println("Unable to load Icon image.");
            e.printStackTrace();
        }*/

        // TEST CODE START
        cachesRegistry.put("cache1", imagesCache1);
        cachesRegistry.put("cache2", imagesCache2);
        // TEST CODE END

        // LOAD FIRST SET OF IMAGES
        DrawDiceFolders(imagesCache1);
        DrawDiceFolders(imagesCache2);
    }

    public static void main(String[] args) {

    }


    @Override
    public void addTo(Buildable parent) {
        if (parent instanceof GameModule) {
            gameModule = (GameModule) parent;
            // CREATE BUTTONS
            URL iconURL = null;
            try {
                iconURL = dataArchive.getURL(ICONS_IMAGES_PATH + "RollDieButton.png");
            } catch (IOException e){
                e.printStackTrace();
            }
            ImageIcon icon = new ImageIcon(iconURL);
            oneDieButton = new DelayedActionButton("", icon, new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    executeRoll(1);
                }
            });
            oneDieButton.setMargin(new Insets(0,3,0,3));
            try {
                iconURL = dataArchive.getURL(ICONS_IMAGES_PATH + "RollDiceButton.png");
            } catch (IOException e){
                e.printStackTrace();
            }
            icon = new ImageIcon(iconURL);
            twoDiceButton = new DelayedActionButton("", icon, new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    executeRoll(2);
                }
            });
            twoDiceButton.setMargin(new Insets(0,3,0,3));

            JButton testButton = new JButton("Test Button");
            ActionListener listener = new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    if (testRunning){
                        testRunning = false;
                    } else {
                        testRunning = true;
                        testRoutine();
                    }
                }
            };
            testButton.addActionListener(listener);
            gameModule.getToolBar().add(testButton);

            // ADD SETTINGS TO PREFERENCE WINDOW
            JToolBar toolBar = gameModule.getToolBar();

            // ...BUTTONS INDEX
            final IntConfigurer buttonsIndexSettings = new IntConfigurer(BUTTONS_INDEX_SETTINGS, "Buttons Position: ", diceToolbarIndex);
            gameModule.getPrefs().addOption(ANIMATED_DICE_PREFERENCES, buttonsIndexSettings);
            diceToolbarIndex = (int) gameModule.getPrefs().getValue(BUTTONS_INDEX_SETTINGS);

            buttonsIndexSettings.addPropertyChangeListener(new PropertyChangeListener() {
                @Override
                public void propertyChange(PropertyChangeEvent evt){
                    int typedValue = (int) gameModule.getPrefs().getValue(BUTTONS_INDEX_SETTINGS);
                    int numberOfSlots = toolBar.getComponentCount() - 1;
                    if (typedValue < 0){
                        gameModule.getPrefs().setValue(BUTTONS_INDEX_SETTINGS, 1);
                        diceToolbarIndex = 1;
                    }
                    if (typedValue > numberOfSlots){
                        gameModule.getPrefs().setValue(BUTTONS_INDEX_SETTINGS, numberOfSlots);
                        diceToolbarIndex = numberOfSlots;
                    } else {
                        diceToolbarIndex = typedValue;
                    }
                    toolBar.add(oneDieButton, diceToolbarIndex);
                    toolBar.add(twoDiceButton, diceToolbarIndex);
                    oneDieButton.setVisible((boolean) gameModule.getPrefs().getValue(ONE_DIE_BUTTON_SETTINGS));
                    twoDiceButton.setVisible((boolean) gameModule.getPrefs().getValue(TWO_DICE_BUTTON_SETTINGS));

                    //gameModule.getToolBar().add(oneDieButton, diceToolbarIndex - 1);
                    toolBar.updateUI();
                };
            });

            // INITIALIZE BUTTONS IN TOOLBAR WITH PROPER INDEX
            if (diceToolbarIndex > toolBar.getComponentCount()) // ----------->>>   SEE IF IT IS POSSIBLE TO ADD BUTTONS AFTER ALL OTHERS ARE ADDED, OR EXTENSIONS INITIALIZED LATER WILL DISLODGE OUR BUTTONS IF SET WITH LAGE INDEX NUMBER
                diceToolbarIndex = toolBar.getComponentCount();
            toolBar.add(oneDieButton, diceToolbarIndex);
            toolBar.add(twoDiceButton, diceToolbarIndex);

            // ...HIDE BUTTONS
            final BooleanConfigurer oneDieButtonSettings = new BooleanConfigurer(ONE_DIE_BUTTON_SETTINGS, "ONE DIE BUTTON ", oneDieButtonVisible);
            final BooleanConfigurer twoDiceButtonSettings = new BooleanConfigurer(TWO_DICE_BUTTON_SETTINGS, "TWO DICE BUTTON ", twoDiceButtonVisible);
            gameModule.getPrefs().addOption(ANIMATED_DICE_PREFERENCES, oneDieButtonSettings);
            gameModule.getPrefs().addOption(ANIMATED_DICE_PREFERENCES, twoDiceButtonSettings);
            oneDieButtonVisible = (boolean) gameModule.getPrefs().getValue(ONE_DIE_BUTTON_SETTINGS);
            twoDiceButtonVisible = (boolean) gameModule.getPrefs().getValue(TWO_DICE_BUTTON_SETTINGS);
            gameModule.getPrefs().setValue(BUTTONS_INDEX_SETTINGS, diceToolbarIndex);
            oneDieButtonSettings.addPropertyChangeListener(new PropertyChangeListener() {
                @Override
                public void propertyChange(PropertyChangeEvent evt){
                    oneDieButton.setVisible((boolean) gameModule.getPrefs().getValue(ONE_DIE_BUTTON_SETTINGS));
                };
            });

            twoDiceButtonSettings.addPropertyChangeListener(new PropertyChangeListener() {
                @Override
                public void propertyChange(PropertyChangeEvent evt){
                    twoDiceButton.setVisible((boolean) gameModule.getPrefs().getValue(TWO_DICE_BUTTON_SETTINGS));
                };
            });

            // Update Dice Buttons visibility
            oneDieButton.setVisible((boolean) gameModule.getPrefs().getValue(ONE_DIE_BUTTON_SETTINGS));
            twoDiceButton.setVisible((boolean) gameModule.getPrefs().getValue(TWO_DICE_BUTTON_SETTINGS));

            // ...DICE ON SCREEN DURATION
            final IntConfigurer onScreenDurationSettings = new IntConfigurer(DICE_ON_SCREEN_DURATION_SETTINGS, "On Screen Duration (MAX: " + MAX_ON_SCREEN_DURATION + " / MIN: " + MIN_ON_SCREEN_DURATION + ")", onScreenDuration);
            gameModule.getPrefs().addOption(ANIMATED_DICE_PREFERENCES, onScreenDurationSettings);
            onScreenDuration = (int) gameModule.getPrefs().getValue(DICE_ON_SCREEN_DURATION_SETTINGS);

            onScreenDurationSettings.addPropertyChangeListener(new PropertyChangeListener() {
                @Override
                public void propertyChange(PropertyChangeEvent evt){
                    if ((int)gameModule.getPrefs().getValue(DICE_ON_SCREEN_DURATION_SETTINGS) > MAX_ON_SCREEN_DURATION) {
                        gameModule.getPrefs().setValue(DICE_ON_SCREEN_DURATION_SETTINGS, MAX_ON_SCREEN_DURATION);
                        onScreenDuration = MAX_ON_SCREEN_DURATION;
                    } else if ((int)gameModule.getPrefs().getValue(DICE_ON_SCREEN_DURATION_SETTINGS) < MIN_ON_SCREEN_DURATION){
                        gameModule.getPrefs().setValue(DICE_ON_SCREEN_DURATION_SETTINGS, MIN_ON_SCREEN_DURATION);
                        onScreenDuration = MIN_ON_SCREEN_DURATION;
                    } else {
                        onScreenDuration = (int)gameModule.getPrefs().getValue((DICE_ON_SCREEN_DURATION_SETTINGS));
                    }
                };
            });

            // ...FRAME RATE
            final IntConfigurer frameRateSettings = new IntConfigurer(FRAME_RATE_SETTINGS, "Frame Rate (MAX: " + MAX_FRAME_RATE + " / MIN: " + MIN_FRAME_RATE + ")", frameRate);
            gameModule.getPrefs().addOption(ANIMATED_DICE_PREFERENCES, frameRateSettings);
            frameRate = Integer.parseInt(gameModule.getPrefs().getValue(FRAME_RATE_SETTINGS).toString());

            frameRateSettings.addFocusListener(new FocusListener() {
                Object initialValue;
                @Override
                public void focusGained(FocusEvent e) {
                    initialValue = gameModule.getPrefs().getValue(FRAME_RATE_SETTINGS);
                }
                @Override
                public void focusLost(FocusEvent e) {
                    Object presentValue = gameModule.getPrefs().getValue(FRAME_RATE_SETTINGS);
                    if (Integer.parseInt(presentValue.toString()) > MAX_FRAME_RATE || Integer.parseInt(presentValue.toString()) < MIN_FRAME_RATE) {
                        gameModule.getPrefs().setValue(FRAME_RATE_SETTINGS, initialValue);
                    } else {
                        gameModule.getPrefs().setValue(FRAME_RATE_SETTINGS, presentValue);
                        frameRate = Integer.parseInt(gameModule.getPrefs().getValue(FRAME_RATE_SETTINGS).toString());
                    }
                }
            });


            // ...DICE POSITION
            MAX_HORIZONTAL_OFFSET = currentMap.getView().getMaximumSize().width; // IMPLEMENT!!

            final IntConfigurer dicePositionSettings = new IntConfigurer(DICE_POSITION_SETTINGS, "Screen Position (MAX: " + MAX_HORIZONTAL_OFFSET + " / MIN: " + 0 + ")", this.dicePositionSettings);
            gameModule.getPrefs().addOption(ANIMATED_DICE_PREFERENCES, dicePositionSettings);
            this.dicePositionSettings = Integer.parseInt(gameModule.getPrefs().getValue(DICE_POSITION_SETTINGS).toString());

            dicePositionSettings.addFocusListener(new FocusListener() {
                Object initialValue;

                @Override
                public void focusGained(FocusEvent e) {
                    initialValue = gameModule.getPrefs().getValue(DICE_POSITION_SETTINGS);
                }

                @Override
                public void focusLost(FocusEvent e) {
                    Object presentValue = gameModule.getPrefs().getValue(DICE_POSITION_SETTINGS);
                    if (Integer.parseInt(presentValue.toString()) > MAX_HORIZONTAL_OFFSET || Integer.parseInt(presentValue.toString()) < 0) {
                        gameModule.getPrefs().setValue(DICE_POSITION_SETTINGS, initialValue);
                    } else {
                        gameModule.getPrefs().setValue(DICE_POSITION_SETTINGS, presentValue);
                        AnimatedDice.this.dicePositionSettings = Integer.parseInt(gameModule.getPrefs().getValue(DICE_POSITION_SETTINGS).toString());
                    }
                }
            });

            // SOUNDS BUTTONS
            // ...HIDE BUTTONS
            final BooleanConfigurer shuffleSoundSettings = new BooleanConfigurer(SHUFFLE_SOUND_SETTINGS, "SHUFFLE SOUND", isShuffleSoundOn);
            final BooleanConfigurer diceSoundSettings = new BooleanConfigurer(DICE_SOUND_SETTINGS, "DICE SOUND", isDiceSoundOn);
            gameModule.getPrefs().addOption(ANIMATED_DICE_PREFERENCES, shuffleSoundSettings);
            gameModule.getPrefs().addOption(ANIMATED_DICE_PREFERENCES, diceSoundSettings);
            isShuffleSoundOn = (boolean) gameModule.getPrefs().getValue(SHUFFLE_SOUND_SETTINGS);
            isDiceSoundOn = (boolean) gameModule.getPrefs().getValue(DICE_SOUND_SETTINGS);
            shuffleSoundSettings.addPropertyChangeListener(new PropertyChangeListener() {
                @Override
                public void propertyChange(PropertyChangeEvent evt){
                    isShuffleSoundOn = (boolean) gameModule.getPrefs().getValue(SHUFFLE_SOUND_SETTINGS);
                };
            });
            diceSoundSettings.addPropertyChangeListener(new PropertyChangeListener() {
                @Override
                public void propertyChange(PropertyChangeEvent evt){
                    isDiceSoundOn = (boolean) gameModule.getPrefs().getValue(DICE_SOUND_SETTINGS);
                };
            });
        }
    }

    private void testRoutine(){
        new Thread (() -> {
            Robot robot;
            try {
                robot = new Robot();
            } catch (AWTException e) {
                e.printStackTrace();
                return; // Handle the exception appropriately based on your application's requirements
            }

            while (testRunning) {
                try {

                    // Move the mouse cursor to a specific position
                    int x = 190; // X-coordinate
                    int y = 70; // Y-coordinate
                    robot.mouseMove(x, y);
                    // Simulate a left mouse button click
                    robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
                    robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
                    Thread.sleep(500);
                } catch (InterruptedException e) {

                }
            }
            Thread.currentThread().interrupt();
        }).start();
    }

    private void loadSounds(){
        try {
            // Preload the audio data into memory
            InputStream dieSoundStream = dataArchive.getInputStream("DiceSounds/Selected1" + ".wav");
            InputStream diceSoundStream = dataArchive.getInputStream("DiceSounds/Selected2" + ".wav"); // For more than one die
            InputStream shakingDiceSoundStream = dataArchive.getInputStream("DiceSounds/Selected3" + ".wav"); // For shaking dice
            dieAudioData = dieSoundStream.readAllBytes();
            diceAudioData = diceSoundStream.readAllBytes();
            shakingDiceAudioData = shakingDiceSoundStream.readAllBytes();
            dieSoundStream.close();
            diceSoundStream.close();
            shakingDiceSoundStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void playSounds(byte[] audioData){
        try{
            AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(new ByteArrayInputStream(audioData));
            Clip clip = AudioSystem.getClip();
            clip.open(audioInputStream);
            new Thread(() -> {
                clip.start();
                try {
                    synchronized (soundObject) {
                        soundObject.wait();
                    }
                } catch (InterruptedException e){

                }
                clip.close();
                Thread.currentThread().interrupt();
            }).start();
            try{  // Works without the try block, but seems to delay the first use of sounds
                audioInputStream.close();
            } catch(IOException e){
                e.printStackTrace();
            }
        } catch (Exception e){
            System.out.println("Exception thrown");
            e.printStackTrace();
        }
    }


    private void executeRoll(int numberOfDice){
        // UNABLE BUTTONS AND HIDE DICE IF NOT YET HIDDEN
        isAnimationInProgress = true;
        oneDieButton.setEnabled(false);
        twoDiceButton.setEnabled(false);

        removeLastFrames();
        // ROLL DICE AND CREATE PIECES
        int[] results = RollDices (numberOfDice, NUMBER_OF_SIDES);
        pieces = new HashMap<>();
        if (numberOfDice == 1) {
            createPieces("white", results[0], oddRound? imagesCache1 : imagesCache2);
        } else if (numberOfDice == 2){
            createPieces("red", results[1], oddRound? imagesCache1 : imagesCache2);
            createPieces("white", results[0], oddRound? imagesCache1 : imagesCache2);
        }

        // START PRELOAD OF NEXT SET OF IMAGES
        //feedingImages = true;
        // since we finished using the current Cache for creating pieces, we can begin to feed it again
        System.out.println("ROUND: " + (oddRound? "odd" : "even"));
        if (oddRound)
            isFeedingCache1 = true;
        else
            isFeedingCache2 = true;
        System.out.println("BEFORE FEEDING -> isFeedingCache1 set to: " + isFeedingCache1 + " //// isFeedingCache2 set to: " + isFeedingCache2);
        try{
            new Thread(() -> {
                HashMap<String, HashMap<Integer, ArrayList<Image>>> cacheUsed = oddRound ? imagesCache1 : imagesCache2;
                DrawDiceFolders(cacheUsed); // Set feedingImages to FALSE after ending feed
                synchronized (feedingImagesLock){ // REMOVE????????????????????????????
                    feedingImagesLock.notify();
                }
                if (cacheUsed == imagesCache1)
                    isFeedingCache1 = false;
                else
                    isFeedingCache2 = false;
                System.out.println("AFTER FEEDING -> isFeedingCache1 set to: " + isFeedingCache1 + " //// isFeedingCache2 set to: " + isFeedingCache2);
                Thread.currentThread().interrupt();
            }).start();
        } catch (Exception e){
            System.out.println("Unable to preload images");
            e.printStackTrace();
        }
        scheduler = Executors.newSingleThreadScheduledExecutor();

        // START SOUNDS
        if (isDiceSoundOn) {
            if (numberOfDice == 1)
                playSounds(dieAudioData);
            else
                playSounds(diceAudioData);
        }
        // SET PARAMETERS
        imageDelay = (1000/frameRate); // transform frame rate into milliseconds delay

        Rectangle rectangle = currentMap.getView().getVisibleRect();
        // If dicePosition (set up in preferences), which is the offset of the animation to the left,
        // is larger than the width of the window minus the width of the images, we adjust it to the maximum place to which the animation may be offset without cropping the image.
        int adjustedDicePositionSettings = (dicePositionSettings > (rectangle.width - (IMAGE_SIZE * numberOfDice))? Math.max (rectangle.width - (IMAGE_SIZE * numberOfDice), 0): dicePositionSettings);
        int min_x = rectangle.x; // leftmost point of the current visible rectangle
        int x = (min_x + adjustedDicePositionSettings); // we add the adjusted offset to the leftmost point of the window.
        int y = rectangle.y;

        int whiteDieAnimationLength = pieces.get("white").length;
        int redDieAnimationLength = (pieces.containsKey("red") ? pieces.get("red").length : 0);
        //System.out.println("N3");
        System.out.println("WHITE DIE ANIM LENGTH: " + whiteDieAnimationLength);
        System.out.println("RED DIE ANIM LENGTH: " + redDieAnimationLength);
        int diePosition = new Random().nextInt(numberOfDice); // always 0 if only one die

        // BEGINS THE ANIMATION
        Runnable task = () -> displayImage(x,y,whiteDieAnimationLength,redDieAnimationLength, diePosition, results);
        scheduler.scheduleAtFixedRate(task, 0, imageDelay, TimeUnit.MILLISECONDS);
    }

    private void removeLastFrames(){
        synchronized (this) {
            if (isImageVisible) { // Checks to see if the last frame is still visible. It can be cleaned when the onScreenDuration time value has passed.
                isImageVisible = false;
                for (String key : pieces.keySet()) {
                    //hideImage(pieces.get(key)[pieces.get(key).length - 1]); // Hide last frame, which remained visible
                    if (pieces.get(key)[pieces.get(key).length - 1] != null) {
                        Command remove = new RemovePiece(pieces.get(key)[pieces.get(key).length - 1]);
                        remove.execute();
                    }
                }
            }
        }
    }

    public void stopAnimation(int[] results){
        // ENDS ANIMATION
        scheduler.shutdown();
        try{
            if (!scheduler.awaitTermination(1, TimeUnit.SECONDS)){
                scheduler.shutdownNow();
                isAnimationInProgress = false;
                currentFrame = 0;
                isImageVisible = true; // can only set this to true after last image is displayed, since when the button is pressed again, the behavior depends on that variable
                oddRound = !oddRound; // We change round so that in the next execution, the other cache will be used and fed.
            }
        } catch (InterruptedException ex){
            System.out.println("Unable to shut down Animation scheduler");
            //scheduler.shutdownNow();
            //Thread.currentThread().interrupt();
        }
        // CLEANS PIECES AND RESET BUTTONS
        final BasicPiece lastRed = pieces.containsKey("red") ? pieces.get("red")[pieces.get("red").length - 1] : null;
        final BasicPiece lastWhite = pieces.get("white")[pieces.get("white").length - 1];
        try { // Remove last piece still visible if not already done after the onScreenDuration time value.
            long startTime = System.currentTimeMillis();
            new Thread(()->{
                while (System.currentTimeMillis() - startTime < (onScreenDuration * 1000)) {
                    if (isAnimationInProgress)
                        break;
                    Thread.yield();
                }
                removeLastFrames();
                Thread.currentThread().interrupt();
            }).start();
        } catch (Exception e){
            e.printStackTrace();
        }

        // We definitely remove each piece so that no artifacts are presented on screen and load new images for each result
        try {
            new Thread(() -> {
                for (String key : pieces.keySet()) {
                    for (BasicPiece piece : pieces.get(key)) {
                        //System.out.println("Piece : " + piece);
                        if (piece != null && !piece.equals(key == "red" ? lastRed : lastWhite)) {
                            Command remove = new RemovePiece(piece);
                            remove.execute();
                        }
                    }
                }
                // If round is odd, ImagesCache1 has been used to create pieces and, after that, it began being fed. ImagesCache2 was fed when round was even
                // and should have been finished by now. If not, the thread waits and prevents buttons to be enabled, avoiding a new round.
                System.out.println("BEFORE ENABLING BUTTONS -> ROUND : " + (oddRound? "odd" : "even"));
                System.out.println("BEFORE ENABLING BUTTONS -> isFeedingCache1 set to: " + isFeedingCache1 + " //// isFeedingCache2 set to: " + isFeedingCache2);
                while (oddRound? isFeedingCache1 : isFeedingCache2) { // CHECKS TO SEE IF THE CACHE TO BE USED IS READY AND ENABLE BUTTONS IF SO.
                    System.out.println("WAITING FOR CACHES! CACHE1 FEEDING: " + isFeedingCache1 + " / CACHE2 FEEDING: " + isFeedingCache2);
                    Thread.yield();
                }
                System.out.println("AFTER WAITING WHILE LOOP! CACHE1 FEEDING: " + isFeedingCache1 + " / CACHE2 FEEDING: " + isFeedingCache2);
                oneDieButton.setEnabled(true);
                twoDiceButton.setEnabled(true);
                sendResults(results.length, results);
                currentMap.getView().repaint();
                Thread.currentThread().interrupt();
            }).start();
        } catch (Exception e) {
            System.out.println("Inside executeRoll. Exception while Resetting Roll Dice Button.");
            e.printStackTrace();
        }
    }

    private void displayImage(int x, int y, int whiteDieAnimationLength, int redDieAnimationLength, int diePosition, int[] results){
        if (currentMap != null){
            if (currentFrame == (whiteDieAnimationLength >= redDieAnimationLength ? whiteDieAnimationLength : redDieAnimationLength)) {
                synchronized (soundObject){
                    soundObject.notify();
                }
                stopAnimation(results);
                return;
            }
            int xCoordinate = x;
            int yCoordinate = y;
                if (redDieAnimationLength == 0) {
                            placePiece(pieces.get("white")[currentFrame], new Point(xCoordinate, yCoordinate));
                        if (currentFrame > 1) {
                                removePiece(pieces.get("white")[currentFrame - 1]);
                        }
                } else if (redDieAnimationLength != 0) {
                    //System.out.println("N5");
                    //System.out.println("Current Frame: " + currentFrame + " and " + (diePosition == 1 ? "Red Animation length :" + redDieAnimationLength:"White Animation length :" + whiteDieAnimationLength));
                    if (currentFrame < (diePosition == 0 ? whiteDieAnimationLength : redDieAnimationLength)) {
                        //System.out.println("N6");
                                placePiece(pieces.get(diePosition == 0 ? "white" : "red")[currentFrame], new Point(xCoordinate, yCoordinate));
                            if (currentFrame > 1) {
                                removePiece(pieces.get(diePosition == 0 ? "white" : "red")[currentFrame - 1]);
                            }
                    }
                    //System.out.println("N7");
                    //System.out.println("Current Frame: " + currentFrame + " and " + (diePosition == 0 ? "Red Animation length :" + redDieAnimationLength:"White Animation length :" + whiteDieAnimationLength));
                    if (currentFrame < (diePosition == 0 ? redDieAnimationLength : whiteDieAnimationLength)) {
                        //System.out.println("N8");
                                placePiece(pieces.get(diePosition == 0 ? "red" : "white")[currentFrame], new Point(xCoordinate + IMAGE_SIZE, yCoordinate));
                            if (currentFrame > 1) {
                                removePiece(pieces.get(diePosition == 0 ? "red" : "white")[currentFrame - 1]);
                            }
                    }
                }
            //System.out.println("N9");
            currentFrame = (currentFrame + 1);
        }
    }

    private synchronized void placePiece(BasicPiece piece, Point point) {
        try {
            if (piece != null)
                currentMap.placeAt(piece, point);
        } catch (Exception e){
            System.out.println("NullPointerException when trying to PLACE the piece at frame: " + currentFrame);
        }
    }

    private synchronized void removePiece(BasicPiece piece) {
        try {
            //System.out.println("PIECE BEFORE REMOVAL: " + piece);
            //System.out.println("IS PIECE NULL? " + (piece == null? "Yes" : "No"));
            if (piece != null) {
                //System.out.println("Inside removal block");
                Command remove = new RemovePiece(piece);
                remove.execute();
            }
        } catch (Exception e){
            System.out.println("NullPointerException when trying to REMOVE the piece at frame: " + currentFrame);
        }
    }

    private void createPieces(String die, int result, HashMap<String, HashMap<Integer, ArrayList<Image>>> cache){
        // In odd rounds we use Cache1 to create the pieces, while Cache2 is being fed.
        int numberOfPieces = cache.get(die).get(result).size();
        System.out.println("CREATE PIECES -> NUMBER OF IMAGES IN CACHE: " + numberOfPieces);
        pieces.put(die, new BasicPiece[numberOfPieces]); // resets the pieces list
        //System.out.println("PIECES CREATION START");
        for (int i = 0; i < numberOfPieces; i++){
            final int index = i; // make index final, so it can be accessed from the inner class
            BasicPiece piece = new BasicPiece() {
                private final Image image = cache.get(die).get(result).get(index);
                @Override
                public void draw(Graphics g, int x, int y, Component obs, double zoom) {
                    super.draw(g, x, y, obs, zoom);
                    // Draw the image at the specified (x, y) coordinates
                        g.drawImage(image, x, y, obs);
                }
            };
            if (piece != null)
                pieces.get(die)[i] = piece;
            //System.out.println("PIECES CREATION END");
        }
    }

    public void getImages(String path, HashMap<String, HashMap<Integer, ArrayList<Image>>> cache, String die, int result){
        int imageNumber = 0;
        Random random = new Random();
        //System.out.println("Path: " + path);
        while (true) {
            try {
                //System.out.println("URL BEFORE");
                URL imageURL = dataArchive.getURL(path + String.format("die%04d", imageNumber) + ".png");
                //System.out.println("URL AFTER: " + imageURL);
                try{
                    //System.out.println("READING IMAGE BEFORE");
                    Image image = ImageIO.read(imageURL);
                    //System.out.println("Image: " + image);
                    //System.out.println("Before adding image to preloadedImages");
                    if (image != null)
                            cache.get(die).get(result).add(image);
                    //System.out.println("READING IMAGE AFTER");
                    imageNumber++;
                } catch (IOException e){
                    System.out.println("FAILED TO LOAD EXISTING IMAGE URL");
                    e.printStackTrace();
                }
            } catch (IOException e) {
                //System.out.println("getImages Exception");
                break;
            }
        }
    }

    private void DrawDiceFolders(HashMap<String, HashMap<Integer, ArrayList<Image>>> cache){
        System.out.println("BEGIN NEW DRAW");
        System.out.println("CACHE USED: " + ((cache.equals(cachesRegistry.get("cache1")))? "CACHE1" : "CACHE2"));
        // Clears the previously preloaded images
        // If round is odd, clears imagesCache1, since it was used to create the pieces in this round before the call to this method.
        for (int i = 1; i <= NUMBER_OF_SIDES; i++){
                cache.get("white").get(i).clear();
                cache.get("red").get(i).clear();
        }
        System.gc();
        // RECOVER THE LAST ANIMATION VARIANT FOR EACH COLOR. O MEANS NONE.
        int lastRedHesitantAnim = (boolean) lastAnimationUsed.get("red")[1] ? (int) lastAnimationUsed.get("red")[0] : 0;
        int lastWhiteHesitantAnim = (boolean) lastAnimationUsed.get("white")[1] ? (int) lastAnimationUsed.get("white")[0] : 0;
        int lastRedAnim = !(boolean) lastAnimationUsed.get("red")[1] ? (int) lastAnimationUsed.get("red")[0] : 0;
        int lastWhiteAnim = !(boolean) lastAnimationUsed.get("white")[1] ? (int) lastAnimationUsed.get("white")[0] : 0;

        double hesitantProb = hesitantDieProbability * ((double)NUMBER_OF_HESITANT_DIE_ANIMATIONS/(double)NUMBER_OF_DIE_ANIMATIONS); // We must update it, since hesitantDieProbability may be changed in preference
        int hesitantDie = 3; // 0 is white, 1 is red and 3 is none
        if((boolean) lastAnimationUsed.get("white")[1] || ((boolean) lastAnimationUsed.get("red")[1] && lastNumberOfDiceRolled == 2)) { // index 1 checks a boolean that is true if the last animation used for that die was a hesitant die animation. Only considers the red die case if it was included in the las toll.
            hesitantProb = hesitantProb * 0.3; // reduces the probability of a sequential hesitant die animation
        }

        //hesitantProb = 1;
        Random random = new Random();
        // BEGIN FEEDING HESITANT DIE IMAGES
        if (random.nextDouble() < hesitantProb){ //Choose among hesitant die animations for red or white die
            hesitantDie = random.nextInt(NUMBER_OF_DICE); // The die that will have the hesitant animation. 0 is white and 1 is red
            int animNumber; // The animation variation to be used
            do {
                animNumber = random.nextInt(NUMBER_OF_HESITANT_DIE_ANIMATIONS) + 1; // there is no animation with index 0
            } while ((lastRedHesitantAnim != 0 && animNumber == lastRedHesitantAnim) || (lastWhiteHesitantAnim != 0 && animNumber ==lastWhiteHesitantAnim)); // prevents immediate repetition of animation if any die used that variation in the last roll

            String folderPrefix = (hesitantDie == 0) ? HESITANT_WHITE_DIE_FOLDER_PATH : HESITANT_RED_DIE_FOLDER_PATH;

            for (int i = 1; i <= NUMBER_OF_SIDES; i++) {
                ArrayList<Integer> animVariation = (hesitantDie == 0) ?
                        whiteHesitantDieFolderBuilder.get(animNumber).get(i) :
                        redHesitantDieFolderBuilder.get(animNumber).get(i);

                StringBuilder path = new StringBuilder();
                path.append(folderPrefix).append((hesitantDie == 0) ? "W" : "R").append(animNumber).append("_")
                        .append(animVariation.get(random.nextInt(animVariation.size()))).append("_").append(i).append("/");
                //System.out.println("HESITANT: PATH BEFORE GET IMAGES");
                //System.out.println(path);
                getImages(path.toString(), cache, (hesitantDie == 0) ? "white" : "red", i);
            }
            if (hesitantDie == 0) {
                lastAnimationUsed.put("white", new Object[]{animNumber, true});
            } else {
                lastAnimationUsed.put("red", new Object[]{animNumber, true});
            }
        }

        // BEGIN FEEDING NORMAL DIE IMAGES
        int redAnimNumber;
        int whiteAnimNumber;

        do {
            redAnimNumber = random.nextInt(NUMBER_OF_DIE_ANIMATIONS) + 1; // there is no animation with index 0
            whiteAnimNumber = random.nextInt(NUMBER_OF_DIE_ANIMATIONS) + 1;
        } while ((lastRedAnim != 0 && (redAnimNumber == lastRedAnim || whiteAnimNumber == lastRedAnim)) || (lastWhiteAnim != 0 && (whiteAnimNumber == lastWhiteAnim || whiteAnimNumber == lastRedAnim)) || (redAnimNumber == whiteAnimNumber)); // prevents immediate repetition of animation and equal animations

        if (hesitantDie != 1) { // RED DIE PRELOAD
            for (int i = 1; i <= NUMBER_OF_SIDES; i++) {
                StringBuilder path = new StringBuilder();
                path.append(RED_DIE_FOLDER_PATH).append("R").append(redAnimNumber).append("_")
                        .append(i).append("/");

                //System.out.println("RED BEFORE GET IMAGES");
                //System.out.println(path);
                getImages(path.toString(), cache, "red", i);
            }
            lastAnimationUsed.put("red", new Object[]{redAnimNumber, false});
        }
        if (hesitantDie != 0) { // WHITE DIE PRELOAD
            for (int i = 1; i <= NUMBER_OF_SIDES; i++) {
                StringBuilder path = new StringBuilder();
                path.append(WHITE_DIE_FOLDER_PATH).append("W").append(whiteAnimNumber).append("_")
                        .append(i).append("/");

                //System.out.println("WHITE BEFORE GET IMAGES");
                //System.out.println(path);
                getImages(path.toString(), cache, "white", i);
            }
            lastAnimationUsed.put("white", new Object[]{whiteAnimNumber, false});
        }

        //feedingImages = false; // Set to true in CreatePieces, after creation is finished and new feed from disk begins
        System.out.println("FINISHED DRAW");
    }
    private void sendResults(int numberOfDice, int[] results){
        //PlayerRoster playerRoster = gameModule.getPlayerRoster();
        //PlayerRoster.PlayerInfo[] currentPlayer = playerRoster.getPlayers();
        String playerId = GlobalOptions.getInstance().getPlayerId();
        System.out.println("HTML: " + GlobalOptions.getInstance().chatterHTMLSupport() + " / HTML SETTINGS: " + GlobalOptions.getInstance().chatterHTMLSetting());
        try {
            String redDie = "";
            if (results.length == 2){
                URL redDieIconURL = dataArchive.getURL(ICONS_IMAGES_PATH + "red" + results[1] + ".png");
                redDie = "<img src='" + redDieIconURL + "' width='25' height='25' style='vertical-align: middle;>";
            }
            URL whiteDieIconURL = dataArchive.getURL(ICONS_IMAGES_PATH + "white" + results[0] + ".png");
            String whiteDie = "<img src='" + whiteDieIconURL + "' width='25' height='25' style='vertical-align: middle;'>";
            StringBuilder report = new StringBuilder();
            report.append("* <b>" + playerId + "</b> " + whiteDie + " " + redDie);

            gameModule.getChatter().send(report.toString());
            String s = "/d6 New string";

        } catch (IOException e){
            e.printStackTrace();
        }

        // Send the formatted message through Chatter
        //gameModule.getChatter().send(formattedMessage);
        //Command c = report.length() == 0 ? new NullCommand() : new Chatter.DisplayText(GameModule.getGameModule().getChatter(), report.toString());
        //((Command)c).execute();
        //GameModule.getGameModule().sendAndLog(c);
    }

    private int[] RollDices (int numberOfDice, int numberOfSides){
        int[] unalteredRolls = DR(numberOfDice,numberOfSides);
        int[] alteredRolls = new int[unalteredRolls.length]; // Rolls after bias application

        for (int i = 0; i < unalteredRolls.length; i++){
            alteredRolls[i] = (unalteredRolls[i] + mouseBiasFactor[i] % 6);
            if (alteredRolls[i] > 6)
                alteredRolls[i] = alteredRolls[i] - 6;
        }
        return alteredRolls;
    }
    protected int[] DR(int nDice, int nSides) {
        int[] rawRolls = new int[nDice];

        for(int i = 0; i < nDice; ++i) {
            Random ran = new Random();
            int roll = ran.nextInt(nSides) + 1;
            rawRolls[i] = roll;
        }

        return rawRolls;
    }

    public void removeFrom(Buildable parent) {
        if (parent instanceof GameModule) {
            GameModule gameModule = (GameModule) parent;

            // Remove the button from the toolbar
            gameModule.getToolBar().remove(oneDieButton);
            gameModule.getToolBar().remove(twoDiceButton);
        }
    }

    // Creates a mask that indicates what animation indexes (the number just to the right of the die color letter in the folder) bring hesitant die animations
    private HashMap<Integer, HashMap<Integer, ArrayList<Integer>>> CreateHesitantDieFolderBuilder(String path){
        HashMap<Integer, HashMap<Integer, ArrayList<Integer>>> folderNameBuilder = new HashMap<>();
        try {
            InputStream inputStream = dataArchive.getInputStream(path);
            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
            String line;
            while ((line = reader.readLine()) != null){
                String[] parts = line.split("/");
                int animationIndex = Integer.parseInt(parts[0]);
                int result = Integer.parseInt(parts[2]);
                int rejectedResult = Integer.parseInt(parts[1]);
                if (!folderNameBuilder.containsKey(animationIndex)) {
                    folderNameBuilder.put(animationIndex, new HashMap<>()); // is a hesitant die animation
                    for (int i = 1; i <= 6; i++) {
                        folderNameBuilder.get(animationIndex).put(i, new ArrayList<Integer>());
                    }
                }
                folderNameBuilder.get(animationIndex).get(result).add(rejectedResult);
            }
        }catch(IOException e){

        }
        /*System.out.println("Before printing");
        for (int i = 1; i <= 5; i++) {
            for (int k = 1; k <= 6; k++) {
                System.out.println("Number of animation: " + i +
                        " brings the following patterns for /'/" + folderNameBuilder.get(i).get(k) +
                        "/'/ result : " + k);
            }
        }*/
        return folderNameBuilder;
    }

    @Override
    public Command decode(String s) {
        return null;
    }
    @Override
    public String encode(Command command){
        return null;
    }

    @Override
    public String[] getAttributeNames(){
        return new String[]{"AnimatedDice"};
    }
    @Override
    public void setAttribute(String attribute, Object object){
        attribute = "AnimatedDice";
        object = new AnimatedDice();
    }

    @Override
    public String getAttributeValueString(String value){
        return "AnimatedDice";
    }

    @Override
    public HelpFile getHelpFile(){
        HelpFile help = new HelpFile();
        return help;
    }
    @Override
    public Class<?>[] getAllowableConfigureComponents() {
        return new Class[]{AnimatedDice.class};
    }

    public class DelayedActionButton extends JButton {
        private boolean mouseButtonPressed = false;
        private ActionListener delayedActionListener;

        public DelayedActionButton(String buttonText, Icon icon, ActionListener delayedActionListener) {
            super(icon);
            this.delayedActionListener = delayedActionListener;
            this.setText(buttonText);
            setupMouseListener();
        }

        private void setupMouseListener() {
            addMouseListener(new MouseAdapter() {
                java.util.Timer timer;
                @Override
                public void mousePressed(MouseEvent e) {
                    //System.out.println("Mouse pressed action inside DelayedActionButton class: NEW ROLL");
                    //System.out.println("isImageVisible: " + isImageVisible + " / isAnimationInProgress: " + isAnimationInProgress);
                    super.mousePressed(e);
                    mouseButtonPressed = true;
                    if (!isAnimationInProgress && isEnabled()) { // doesn't execute when pressed to hide the dices (dice images are still visible)
                        //setCursor(dieCursor);
                        if (isShuffleSoundOn)
                            playSounds(shakingDiceAudioData);
                        mouseBiasFactor = new int[NUMBER_OF_DICE]; // We'll the number of factors correspondent to the number of dice;
                        Arrays.fill(mouseBiasFactor, 1);
                        final int[] counter = new int[]{0}; // Use of single element array in order to be able to change it inside runnable.
                        final long startTime = System.currentTimeMillis();
                        timer = new java.util.Timer();
                        JButton button = (JButton) e.getSource();
                        Color originalColor = new Color(238,238,238);

                        timer.schedule(new TimerTask() {
                            long colorCounter = 10;
                            @Override
                            public void run() {
                                //System.out.println("Mouse Position: " + MouseInfo.getPointerInfo().getLocation());

                                long elapsedTime = System.currentTimeMillis() - startTime;
                                if (elapsedTime >= 5000) {
                                        this.cancel();
                                } else {
                                    if (elapsedTime > colorCounter) {
                                        if (button.getBackground() == originalColor)
                                            button.setBackground(Color.YELLOW);
                                        else
                                            button.setBackground(originalColor);
                                        colorCounter += 100;
                                    }

                                    mouseBiasFactor[counter[0]] += MouseInfo.getPointerInfo().getLocation().x + MouseInfo.getPointerInfo().getLocation().y;
                                    if (mouseBiasFactor[counter[0]] > 10000)
                                        mouseBiasFactor[counter[0]] = mouseBiasFactor[counter[0]] - 10000;

                                    if (counter[0] == mouseBiasFactor.length - 1) {
                                        counter[0] = 0;
                                    } else {
                                        counter[0] = counter[0] + 1;
                                    }
                                }
                                //System.out.println("Bias " + counter[0] + " = " + mouseBiasFactor[counter[0]]);
                            }
                        }, 0, 10);
                    }
                }


                @Override
                public void mouseReleased(MouseEvent e) {
                    super.mouseReleased(e);
                    //setCursor(Cursor.getDefaultCursor());
                    Color originalColor = new Color(238,238,238);
                    JButton button = (JButton) e.getSource();

                    if (mouseButtonPressed && isEnabled()) {
                        try{ // Necessary to allow sound to begin and notify to work properly
                            Thread.sleep(100);
                        } catch (InterruptedException a){

                        }
                        synchronized (soundObject){
                            soundObject.notify();
                        }
                        try{ // Necessary to allow sound to begin and notify to work properly
                            Thread.sleep(100);
                        } catch (InterruptedException a){

                        }
                        if (timer != null) {
                            timer.cancel();
                        }
                        if (e.getButton() == MouseEvent.BUTTON1) { // if left button, display animation
                            delayedActionListener.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ""));
                        } else {
                            if (e.getSource() == oneDieButton){
                                RollDices(1, 6);
                            }
                            if (e.getSource() == twoDiceButton){
                                RollDices(2, 6);
                            }
                        }
                    }
                    button.setBackground(originalColor);
                    mouseButtonPressed = false;
                }
            });
        }
    }
}


