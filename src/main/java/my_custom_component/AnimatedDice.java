package my_custom_component;

import VASSAL.build.AbstractConfigurable;
import VASSAL.build.Buildable;
import VASSAL.build.GameModule;
import VASSAL.build.module.Chatter;
import VASSAL.build.module.Map;
import VASSAL.build.module.documentation.HelpFile;
import VASSAL.command.Command;
import VASSAL.command.CommandEncoder;
import VASSAL.command.NullCommand;
import VASSAL.command.RemovePiece;
import VASSAL.configure.IntConfigurer;
import VASSAL.counters.BasicPiece;

import javax.imageio.ImageIO;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public final class AnimatedDice extends AbstractConfigurable implements CommandEncoder, Buildable{
    private GameModule gameModule;
    //private static final String IMAGES_FOLDER = System.getProperty("user.dir") + "/resources/images/";
    //private static final String SOUNDS_FOLDER = System.getProperty("user.dir") + "/resources/sounds/";
    private String RED_DIE_FOLDER_PATH = "images/DiceImages/RED DIE/";
    private String WHITE_DIE_FOLDER_PATH = "images/DiceImages/WHITE DIE/";
    private final String ANIMATED_DICE_PREFERENCES = "Animated 3D Dice";
    private final String FRAME_RATE_SETTINGS = "frameRateSettings";
    private final String DICE_POSITION_SETTINGS = "dicePositionSettings";
    private int dicePositionSettings;
    private int MAX_HORIZONTAL_OFFSET = 0;
    private int IMAGE_SIZE = 250;
    private boolean isImageVisible; // establish if last dice frame is still visible in the screen so that the button is in Hide mode.
    private boolean isAnimationInProgress = false; // prevents mousePress action before animation finishes.
    private JButton customButton;
    private int[] mouseBiasFactor; // Set of ints generated by mouse movement which will influence dice results
    private int nDice; // number of dices rolled
    private int nSides; // number of sides of a die
    private long imageDelay; // The number of MILLISECONDS between the display actions.
    private int currentFrame;
    private int frameRate;
    private final int MAX_FRAME_RATE = 60;
    private final int MIN_FRAME_RATE = 35;
    private ScheduledExecutorService scheduler; // Controls the frame rate of the displayed images
    private Image[] images; // to be fed with the dice images that will be drawn on the pieces
    private java.util.Map<String, Image[]> diceImages;
    private int[] lastDiceImageFolderIndexes = new int[]{0,0}; // Keeps the last two dice image folders indexes stored to prevent immediate repetition of same animation
    private java.util.Map<Integer, java.util.Map<Integer, ArrayList<String>>> hesitantDiceFolderIndexes; // keeps a list of folders which bring animation of paired hesitant dice, for which the player can set the rarity of occurrence.
    private boolean feedingImages; // Checks if the thread for loading images is still running
    private byte[] dieAudioData;
    private byte[] diceAudioData;
    private byte[] shakingDiceAudioData;
    private boolean shouldStopFlag;
    private Cursor dieCursor;
    private boolean actionInProgress = false;
    private BasicPiece[] pieces; // pieces are added to this array to be displayed in order
    private final Map currentMap;

    public AnimatedDice(){
        isImageVisible = false;
        gameModule = GameModule.getGameModule();
        currentMap = GameModule.getGameModule().getComponentsOf(Map.class).get(0);
        dicePositionSettings = 0;
        frameRate = 45;
        currentFrame = 0;
        nDice = 2;
        nSides = 6;

        // GET RESOURCES
        loadSounds(); // Preloads sounds for dices
        URL dieCursorImageURL = getClass().getResource("images/DieCursor.png");
        try {
            BufferedImage dieCursorImage = ImageIO.read(dieCursorImageURL);
            dieCursor = Toolkit.getDefaultToolkit().createCustomCursor(dieCursorImage, new Point(0,0), "Custom Die Cursor");
        } catch (IOException e) {
            e.printStackTrace();
        }
        // LOAD FIRST SET OF IMAGES
        getImages();
        // CREATE THE ARRAY INDICATING WHAT FOLDERS BRING HESITANT DIE ANIMATIONS
        CreateHesitantDieFolderMask();
    }

    public static void main(String[] args) {

    }


    @Override
    public void addTo(Buildable parent) {
        if (parent instanceof GameModule) {
            gameModule = (GameModule) parent;
            // Create your button instance
            customButton = new DelayedActionButton("Roll Dice", new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    toggleImagesVisibility();
                }
            });
            customButton.setToolTipText("Displays Image on map");

            // Add the button to the toolbar
            gameModule.getToolBar().add(customButton);

            // ADD SETTINGS TO PREFERENCE WINDOW

            // FRAME RATE
            final IntConfigurer frameRateSettings = new IntConfigurer(FRAME_RATE_SETTINGS, "Frame Rate (MAX: " + MAX_FRAME_RATE + " / MIN: " + MIN_FRAME_RATE + ")", frameRate);
            gameModule.getPrefs().addOption(ANIMATED_DICE_PREFERENCES, frameRateSettings);
            frameRate = Integer.parseInt(gameModule.getPrefs().getValue(FRAME_RATE_SETTINGS).toString());

            frameRateSettings.addFocusListener(new FocusListener() {
                Object initialValue;
                @Override
                public void focusGained(FocusEvent e) {
                    initialValue = gameModule.getPrefs().getValue(FRAME_RATE_SETTINGS);
                }
                @Override
                public void focusLost(FocusEvent e) {
                    Object presentValue = gameModule.getPrefs().getValue(FRAME_RATE_SETTINGS);
                    if (Integer.parseInt(presentValue.toString()) > MAX_FRAME_RATE || Integer.parseInt(presentValue.toString()) < MIN_FRAME_RATE) {
                        gameModule.getPrefs().setValue(FRAME_RATE_SETTINGS, initialValue);
                    } else {
                        gameModule.getPrefs().setValue(FRAME_RATE_SETTINGS, presentValue);
                        frameRate = Integer.parseInt(gameModule.getPrefs().getValue(FRAME_RATE_SETTINGS).toString());
                    }
                }
            });


            // DICE POSITION
            MAX_HORIZONTAL_OFFSET = currentMap.getView().getMaximumSize().width; // IMPLEMENT!!

            final IntConfigurer dicePositionSettings = new IntConfigurer(DICE_POSITION_SETTINGS, "Screen Position (MAX: " + MAX_HORIZONTAL_OFFSET + " / MIN: " + 0 + ")", this.dicePositionSettings);
            gameModule.getPrefs().addOption(ANIMATED_DICE_PREFERENCES, dicePositionSettings);
            this.dicePositionSettings = Integer.parseInt(gameModule.getPrefs().getValue(DICE_POSITION_SETTINGS).toString());

            dicePositionSettings.addFocusListener(new FocusListener() {
                Object initialValue;

                @Override
                public void focusGained(FocusEvent e) {
                    initialValue = gameModule.getPrefs().getValue(DICE_POSITION_SETTINGS);
                }

                @Override
                public void focusLost(FocusEvent e) {
                    Object presentValue = gameModule.getPrefs().getValue(DICE_POSITION_SETTINGS);
                    if (Integer.parseInt(presentValue.toString()) > MAX_HORIZONTAL_OFFSET || Integer.parseInt(presentValue.toString()) < 0) {
                        gameModule.getPrefs().setValue(DICE_POSITION_SETTINGS, initialValue);
                    } else {
                        gameModule.getPrefs().setValue(DICE_POSITION_SETTINGS, presentValue);
                        AnimatedDice.this.dicePositionSettings = Integer.parseInt(gameModule.getPrefs().getValue(DICE_POSITION_SETTINGS).toString());
                    }
                }
            });
        }
    }

    private void loadSounds(){
        InputStream dieSoundStream = getClass().getResourceAsStream( "sounds/Selected1" + ".wav");
        InputStream diceSoundStream = getClass().getResourceAsStream("sounds/Selected2" + ".wav"); // For more than one die
        InputStream shakingDiceSoundStream = getClass().getResourceAsStream("sounds/Selected3" + ".wav"); // For shaking dice

        // Preload the audio data into memory
        try {
            dieAudioData = dieSoundStream.readAllBytes();
            diceAudioData = diceSoundStream.readAllBytes();
            shakingDiceAudioData = shakingDiceSoundStream.readAllBytes();
        } catch (IOException e){
            System.out.println("Exception reading sounds data");
            e.printStackTrace();
        }
        try {
            dieSoundStream.close(); // Close the stream
            diceSoundStream.close();
        } catch (IOException e){
            e.printStackTrace();
        }
    }

    private void playSounds(byte[] audioData){
        try{
            AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(new ByteArrayInputStream(audioData));
            Clip clip = AudioSystem.getClip();
            clip.open(audioInputStream);
            new Thread(() -> {
                clip.start();
                while (clip.getFramePosition() < clip.getFrameLength()){
                    if (shouldStopFlag)
                        clip.close();
                    Thread.yield();
                }
                clip.close();
                Thread.currentThread().interrupt();
            }).start();
            try{  // Works without the try block, but seems to delay the first use of sounds
                audioInputStream.close();
            } catch(IOException e){
                e.printStackTrace();
            }
        } catch (Exception e){
            System.out.println("Exception thrown");
            e.printStackTrace();
        }
        shouldStopFlag = false;
    }


    private void toggleImagesVisibility(){
        // ENDS THE ANIMATION
        if (isImageVisible){
            customButton.setEnabled(false);
            hideImage(pieces[pieces.length - 1]); // Hide last frame, which remained visible
            isImageVisible = false;
            // We definitely remove each piece so that no artifacts are presented on screen and load new images for each result
            try{
                new Thread(() -> {
                    feedingImages = true;
                    for (BasicPiece piece: pieces){
                        Command remove = new RemovePiece(piece);
                        remove.execute();
                    }
                    getImages();
                    while (feedingImages){
                        Thread.yield();
                    }
                    customButton.setText("Roll Dice");
                    customButton.setEnabled(true);
                    currentMap.getView().repaint();
                    Thread.currentThread().interrupt();
                }).start();
            } catch (Exception e){
                System.out.println("Exception thrown");
                e.printStackTrace();
            }


        } else {
            // BEGINS THE ANIMATION
            isAnimationInProgress = true;
            customButton.setEnabled(false);
            imageDelay = (1000/frameRate); // transform frame rate into milliseconds delay
            RollDices (nDice, nSides);
            createPieces();
            scheduler = Executors.newSingleThreadScheduledExecutor();
            playSounds(dieAudioData);

            Rectangle rectangle = currentMap.getView().getVisibleRect();
            // If dicePosition (set up in preferences), which is the offset of the animation to the left,,
            // is larger than the width of the window minus the width of the images, we adjust it to the maximum place to which the animation may be offset without cropping the image.
            int adjustedDicePositionSettings = (dicePositionSettings > (rectangle.width - IMAGE_SIZE))? Math.max (rectangle.width - IMAGE_SIZE, 0): dicePositionSettings;
            int min_x = rectangle.x; // leftmost point of the current visible rectangle
            int x = (min_x + adjustedDicePositionSettings); // we add the adjusted offset to the leftmost point of the window.
            int y = rectangle.y;

            Runnable task = () -> displayImage(x,y);
            scheduler.scheduleAtFixedRate(task, 0, imageDelay, TimeUnit.MILLISECONDS);
        }
    }

    public void stopImageDisplay(){
        scheduler.shutdown();
        try{
            if (!scheduler.awaitTermination(1, TimeUnit.SECONDS)){
                scheduler.shutdownNow();
                customButton.setEnabled(true);
                isAnimationInProgress = false;
            }
        } catch (InterruptedException ex){
            scheduler.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    private void displayImage(int x, int y){
        if (currentMap != null){
            if (currentFrame == pieces.length) {
                stopImageDisplay();
                currentFrame = 0;
                isImageVisible = true; // can only set this to true after last image is displayed, since when the button is pressed again, the behavior depends on that variable.
                customButton.setText("Hide Dice");
                return;
            }

            int xCoordinate = x;
            int yCoordinate = y;

            currentMap.placeAt(pieces[currentFrame], new Point(xCoordinate,yCoordinate));
            if (currentFrame > 1){
                currentMap.removePiece(pieces[currentFrame - 1]);
            }

            currentFrame = (currentFrame + 1);
        }
    }

    private void hideImage(BasicPiece piece) {
        if (currentMap != null) {
            currentMap.removePiece(piece);
            currentMap.repaint();
        }
    }

    private void createPieces(){
        int numberOfPieces = images.length;
        pieces = new BasicPiece[numberOfPieces];
        for (int i = 0; i < numberOfPieces; i++){
            final int index = i; // make index final, so it can be accessed from the inner class
            BasicPiece piece = new BasicPiece() {
                private final Image image = images[index];
                @Override
                public void draw(Graphics g, int x, int y, Component obs, double zoom) {
                    super.draw(g, x, y, obs, zoom);
                    // Draw the image at the specified (x, y) coordinates
                    g.drawImage(image, x, y, obs);
                }
            };
            pieces[i] = piece;
        }
    }

    /* // Retrieve dice images from the proper folder and places them into the images Array;
     public void getImages(){
         int filesInFolder = countFilesInFolder(System.getProperty("user.dir") + "/target/classes/" + IMAGES_FOLDER + "/DiceImages/RED DIE/R1_1/");
         images = new Image[filesInFolder];
         for (int i = 0; i < filesInFolder; i++) {
             try {
                 URL imageURL = getClass().getResource("/" + IMAGES_FOLDER + "/DiceImages/RED DIE/R1_1/" + String.format("die%04d", i) + ".png");
                 if (imageURL != null) {
                     images[i] = (ImageIO.read(imageURL));
                 } else {
                     throw new IOException("Image file not found.");
                 }
             } catch (IOException e) {
                 e.printStackTrace();
             }
         }
         feedingImages = false;
     }*/
    // Retrieve dice images from the proper folder and places them into the images Array;
    public void getImages(){
        String[] diceFolders = DrawDiceFolders(); // chooses the next animation folders to preload
        diceImages = new HashMap<>();
        int filesInFolder = countFilesInFolder( RED_DIE_FOLDER_PATH + "/R1_1/");
        images = new Image[filesInFolder];
        for (int i = 0; i < filesInFolder; i++) {
            try {
                URL imageURL = getClass().getResource(RED_DIE_FOLDER_PATH + "/R1_1/" + String.format("die%04d", i) + ".png");
                if (imageURL != null) {
                    images[i] = (ImageIO.read(imageURL));
                } else {
                    throw new IOException("Image file not found.");
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        feedingImages = false;
    }

    private String[] DrawDiceFolders(){
        return null;
    }

    private void RollDices (int numberOfDice, int numberOfSides){
        int[] unalteredRolls = DR(numberOfDice,numberOfSides);
        int[] alteredRolls = new int[unalteredRolls.length]; // Rolls after bias application

        for (int i = 0; i < unalteredRolls.length; i++){
            alteredRolls[i] = (unalteredRolls[i] + mouseBiasFactor[i] % 6);
            if (alteredRolls[i] > 6)
                alteredRolls[i] = alteredRolls[i] - 6;
        }

        StringBuilder report = new StringBuilder();
        report.append("Original Rolls: ");
        for (int j = 0; j < nDice; ++j){
            report.append(unalteredRolls[j]);
            if (j < nDice - 1)
                report.append(", ");
        }
        report.append("Altered Rolls: ");
        for (int k = 0; k < nDice; ++k){
            report.append(alteredRolls[k]);
            if (k < nDice - 1)
                report.append(", ");
        }

        Command c = report.length() == 0 ? new NullCommand() : new Chatter.DisplayText(GameModule.getGameModule().getChatter(), report.toString());
        ((Command)c).execute();
        GameModule.getGameModule().sendAndLog(c);
    }
    protected int[] DR(int nDice, int nSides) {
        int[] rawRolls = new int[nDice];

        for(int i = 0; i < nDice; ++i) {
            Random ran = new Random();
            int roll = ran.nextInt(nSides) + 1;
            rawRolls[i] = roll;
        }

        return rawRolls;
    }

    public void removeFrom(Buildable parent) {
        if (parent instanceof GameModule) {
            GameModule gameModule = (GameModule) parent;

            // Remove the button from the toolbar
            gameModule.getToolBar().remove(customButton);
        }
    }

    private static int countFilesInFolder(String folderPath) {
        File folder = new File(folderPath);
        if (!folder.exists() || !folder.isDirectory()) {
            java.lang.System.out.println(folderPath);
            java.lang.System.out.println("The specified folder does not exist or is not a directory.");
            return 0;
        }

        String[] files = folder.list();
        if (files == null) {
            java.lang.System.out.println("Error listing files in the folder.");
            return 0;
        }

        return files.length;
    }

    // Creates a mask that indicates what animation indexes (the number just to the right of the die color letter in the folder) bring hesitant die animations
    private void CreateHesitantDieFolderMask(){
        File directory = new File (RED_DIE_FOLDER_PATH);
        if (directory.exists() && directory.isDirectory()){
            File[] subdirectories = directory.listFiles(File::isDirectory);
            hesitantDiceFolderIndexes = new HashMap<>();
            int counter = 0;
            if (subdirectories != null){
                // Pattern for paired hesitant die animation: Ex.  "R2_6_3"
                Pattern hesitantDieFolderPattern = Pattern.compile("^[A-Za-z]\\d+_\\d_\\d$");
                for (File subdirectory : subdirectories){
                    String folderName = subdirectory.getName();

                    Matcher matcher1 = hesitantDieFolderPattern.matcher(folderName);
                    if (matcher1.matches()){
                        String[] parts = folderName.split("_");

                        int animationIndex = Integer.parseInt(parts[0].substring(1));
                        int result = Integer.parseInt(parts[2]);
                        if (!hesitantDiceFolderIndexes.containsKey(animationIndex)) {
                            hesitantDiceFolderIndexes.put(animationIndex, new HashMap<>()); // is a hesitant die animation
                            for (int i = 1; i <= 6; i++) {
                                hesitantDiceFolderIndexes.get(animationIndex).put(i, new ArrayList<String>());
                            }
                        }
                        hesitantDiceFolderIndexes.get(animationIndex).get(result).add("_" + parts[1]);

                        System.out.println("Number of animation: " + animationIndex + " brings the following patterns for result " + parts[2] + ": " + hesitantDiceFolderIndexes.get(animationIndex).get(result));
                    }
                }
            }
        }
    }

    @Override
    public Command decode(String s) {
        return null;
    }
    @Override
    public String encode(Command command){
        return null;
    }

    @Override
    public String[] getAttributeNames(){
        return new String[]{"AnimatedDice"};
    }
    @Override
    public void setAttribute(String attribute, Object object){
        attribute = "AnimatedDice";
        object = new AnimatedDice();
    }

    @Override
    public String getAttributeValueString(String value){
        return "AnimatedDice";
    }
    @Override
    public String[] getAttributeDescriptions() {
        return new String[]{"3D dices"};
    }

    @Override
    public Class<?>[] getAttributeTypes() {
        return new Class[]{AnimatedDice.class};
    }

    @Override
    public HelpFile getHelpFile(){
        HelpFile help = new HelpFile();
        return help;
    }
    @Override
    public Class<?>[] getAllowableConfigureComponents() {
        return new Class[]{AnimatedDice.class};
    }

    public class DelayedActionButton extends JButton {
        private boolean mouseButtonPressed = false;
        private ActionListener delayedActionListener;

        public DelayedActionButton(String buttonText, ActionListener delayedActionListener) {
            super();
            this.delayedActionListener = delayedActionListener;
            this.setText(buttonText);
            setupMouseListener();
        }

        private void setupMouseListener() {
            addMouseListener(new MouseAdapter() {
                java.util.Timer timer;
                @Override
                public void mousePressed(MouseEvent e) {
                    System.out.println("NEW ROLL");
                    super.mousePressed(e);
                    mouseButtonPressed = true;
                    if (!isImageVisible && !isAnimationInProgress) { // doesn't execute when pressed to hide the dices (dice images are still visible)
                        setCursor(dieCursor);
                        playSounds(shakingDiceAudioData);
                        mouseBiasFactor = new int[nDice]; // We'll the number of factors correspondent to the number of dice;
                        Arrays.fill(mouseBiasFactor, 1);
                        final int[] counter = new int[]{0}; // Use of single element array in order to be able to change it inside runnable.

                        timer = new java.util.Timer();
                        timer.schedule(new TimerTask() {
                            @Override
                            public void run() {
                                System.out.println("Mouse Position: " + MouseInfo.getPointerInfo().getLocation());

                                mouseBiasFactor[counter[0]] += MouseInfo.getPointerInfo().getLocation().x + MouseInfo.getPointerInfo().getLocation().y;
                                if (mouseBiasFactor[counter[0]] > 10000)
                                    mouseBiasFactor[counter[0]] = mouseBiasFactor[counter[0]] - 10000;

                                if (counter[0] == mouseBiasFactor.length - 1) {
                                    counter[0] = 0;
                                } else {
                                    counter[0] = counter[0] + 1;
                                }
                                System.out.println("Bias " + counter[0] + " = " + mouseBiasFactor[counter[0]]);
                            }
                        }, 0, 10);
                    }
                }

                @Override
                public void mouseReleased(MouseEvent e) {
                    super.mouseReleased(e);
                    setCursor(Cursor.getDefaultCursor());
                    if (mouseButtonPressed && isEnabled()) {
                        shouldStopFlag = true;
                        timer.cancel();
                        delayedActionListener.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ""));
                    }
                    mouseButtonPressed = false;
                }
            });
        }
    }

}


